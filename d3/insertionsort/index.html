<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
    width:960px;
    margin:10px auto;
}
rect {
  stroke:darkgreen;  
  stroke-width:3px;
}
line {
  stroke-width:3px;
}
#insertionsvg g text:hover, #insertionsvg g rect:hover {
    cursor:pointer;
}
#navdiv {
    background:#555;
}
#insertionsvg {
    border:2px solid grey;
}
#navdiv button, #navdiv textarea {
    vertical-align:middle;
}
#g_labels text {
    text-anchor:middle;
    font-family:'Verdana';
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

// this functions creates and returns an insertion sort
// visualization object
// list is the list of elements to be sorted
function insertionSortViz(list, dur) {
    var boxSize = 80; // size of each array slot
    var fontSize = 50; // array element font size
    var svgW = 958, svgH = 460; // svg canvas size
    var insertion = {}; // insertion sort visualization
    var intervalID = null; // for storing interval timer's ID
    var q = []; // queue for storing actions on the visualization

    // default to 10 elements if no list is provided
    if (!list || list.length < 1) {
        insertion.N = 10;
        list = d3.range(1, insertion.N);
        d3.shuffle(list);
    } else {
        insertion.N = list.length;
    }

    // create lists of array slots and elements
    insertion.slots = [];
    insertion.X = (svgW - insertion.N * boxSize + boxSize) / 2;
    insertion.Y = (svgH - boxSize) / 2;
    insertion.I = {val:'i', pos:{x:insertion.X, y:insertion.Y + boxSize}};
    insertion.J = {val:'j', pos:{x:insertion.X, y:insertion.Y - boxSize / 1.3}};
    // initialize boundary marking sorted elements
    insertion.bound = {
        pos:{x1:insertion.X - boxSize / 2,
             y1:insertion.Y - boxSize / 2 - 20,
             x2:insertion.X - boxSize / 2,
             y2:insertion.Y + boxSize / 2 + 20}
    };
    list.forEach(function(e, i) {
        insertion.slots.push({
            pos:{x:insertion.X + i * boxSize, y:insertion.Y},
            elem:{val:e, seq:i,
                pos:{x:insertion.X + i * boxSize, y:insertion.Y},
            },
            fill:'white'
        });
    });


    // highlight elements at indices
    insertion.highlight = function(indices) {
        q.push(function() {
            indices.forEach(function(i) {
                insertion.slots[i].fill = 'lime';
            });
        });
    }

    // clear the highlighting of elements at indices
    insertion.unhighlight = function(indices) {
        q.push(function() {
            indices.forEach(function(i) {
                insertion.slots[i].fill = 'white';
            });
        });
    }

    // swap elements at specified indices
    insertion.swap = function(i, j) {
        q.push(function() {
            // update position to new position
            insertion.slots[i].elem.pos.x = insertion.slots[j].pos.x;
            insertion.slots[j].elem.pos.x = insertion.slots[i].pos.x;
            var tmp = insertion.slots[i].elem;
            insertion.slots[i].elem = insertion.slots[j].elem;
            insertion.slots[j].elem = tmp;
        });
    }

    // update sorted boundary to the right of index i
    insertion.updateBoundary = function(i) {
        q.push(function() {
            insertion.bound.pos.x1 = insertion.X - boxSize / 2 +
                                                boxSize * (i + 1);
            insertion.bound.pos.x2 = insertion.bound.pos.x1;
        });
    }

    // update i
    insertion.updateI = function(index) {
        q.push(function() {
            insertion.I.pos.x = insertion.slots[index].pos.x;
        });
    }

    // update j
    insertion.updateJ = function(index) {
        q.push(function() {
            insertion.J.pos.x = insertion.slots[index].pos.x;
        });
    }

    // take the next step in the algorithm
    // (executes every dur milliseconds)
    insertion.step = function() {
        if (q.length > 0) {
            var callback = q.shift();
            callback();
            redraw();
        }
    }

    // pause or play the visualization
    insertion.pauseplay = function() {
        if (!intervalID) {
            intervalID = setInterval(insertion.step, dur);
        } else {
            clearInterval(intervalID);
            intervalID = null;
        }
    }

    // get the list of elements in original sequence order
    var getAllElems = function() {
        elements = [];
        insertion.slots.forEach(function(slot) {
            elements.push(slot.elem);
        });
        return elements.sort(function(a, b) { return a.seq - b.seq; });
    }

    // draw the array and its elements
    redraw = function() {
        // draw all array slots
        var rects = d3.select("#g_arrelems")
                        .selectAll('rect')
                        .data(insertion.slots);

        rects.transition().duration(dur)
            .attr('x', function(d) { return d.pos.x - boxSize / 2; })
            .attr('y', function(d) { return d.pos.y - boxSize / 2; })
            .attr('width', function(d) { return boxSize; })
            .attr('height', function(d) { return boxSize; })
            .attr('fill', function(d) { return d.fill; });

        rects.enter()
            .append('rect')
            .attr('x', function(d) { return d.pos.x - boxSize / 2; })
            .attr('y', function(d) { return d.pos.y - boxSize / 2; })
            .attr('width', function(d) { return boxSize; })
            .attr('height', function(d) { return boxSize; })
            .attr('fill', 'white')
            .transition().duration(dur)
            .attr('fill', function(d) { return d.fill; })
            .attr('x', function(d) { return d.pos.x - boxSize / 2; })
            .attr('y', function(d) { return d.pos.y - boxSize / 2; });

        // draw all elements
        var elems = d3.select("#g_labels")
                        .selectAll('text')
                        .data(getAllElems());

        elems.text(function(d) { return d.val; })
            .transition().duration(dur)
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 1/3 * fontSize; });

        elems.enter()
            .append('text')
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 1/3 * fontSize; })
            .attr('fill', 'blue')
            .attr('font-size', fontSize)
            .text(function(d) { return d.val; })
            .transition().duration(dur)
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 1/3 * fontSize; });

        // draw sorted boundary
        d3.select("#boundary")
            .transition().duration(dur)
            .attr('x1', insertion.bound.pos.x1)
            .attr('x2', insertion.bound.pos.x2)
            .attr('y1', insertion.bound.pos.y1)
            .attr('y2', insertion.bound.pos.y2);

        // draw i
        d3.select("#i").text(insertion.I.val)
            .transition().duration(dur)
            .attr('x', insertion.I.pos.x)
            .attr('y', insertion.I.pos.y)
            .attr('font-size', fontSize);

        // draw j
        d3.select("#j").text(insertion.J.val)
            .transition().duration(dur)
            .attr('x', insertion.J.pos.x)
            .attr('y', insertion.J.pos.y)
            .attr('font-size', fontSize);

        // draw j - 1
        d3.select("#jminus1").text(insertion.J.val.concat('-1'))
            .transition().duration(dur)
            .attr('x', insertion.J.pos.x - boxSize * 1.3)
            .attr('y', insertion.J.pos.y)
            .attr('font-size', fontSize);
    }
    
    // initialize the visualization layout
    initialize = function() {
        // append svg header bar
        d3.select("body")
            .append("div")
            .attr('id','navdiv');
        
        // add start button to header bar
        d3.select("#navdiv")
            .append("button")
            .attr('type','button')
            .text('Pause/Play')
            .on('click', function(d) { insertion.pauseplay(); });
        
        // append the svg canvas
        d3.select("body")
            .append("svg")
            .attr("width", svgW)
            .attr("height", svgH)
            .attr('id','insertionsvg');

        // append element for holding array elements
        d3.select("#insertionsvg")
            .append('g')
            .attr('id','g_arrelems');
            
        // append element for holding array element labels
        d3.select("#insertionsvg")
            .append('g')
            .attr('id','g_labels');

        // append element for holding sorted boundary line
        d3.select("#insertionsvg")
            .append('line')
            .attr('id','boundary')
            .attr('stroke','black');

        // append element for holding i
        d3.select("#insertionsvg")
            .append('text')
            .attr('id','i')
            .attr('stroke','black');

        // append element for holding j
        d3.select("#insertionsvg")
            .append('text')
            .attr('id','j')
            .attr('stroke','black');

        // append element for holding j - 1
        d3.select("#insertionsvg")
            .append('text')
            .attr('id','jminus1')
            .attr('stroke','black');

        // display initial array
        redraw();
    }
    initialize();
    return insertion;
}

// example of a client using the insertion visualization
var l = d3.range(1,11);
d3.shuffle(l);
var insertion = insertionSortViz(l, 1000);
insertion.highlight([0]);
insertion.unhighlight([0]);
insertion.updateBoundary(0);

// insertion sort implementation
for (var i = 1; i < l.length; i++) {
    insertion.updateI(i);
    for (var j = i; j > 0; j--) {
        insertion.updateJ(j);
        insertion.highlight([j - 1, j]);
        if (l[j] < l[j - 1]) {
            var tmp = l[j - 1];
            l[j - 1] = l[j];
            l[j] = tmp;
            insertion.swap(j - 1, j);
            insertion.unhighlight([j - 1, j]);
        } else {
            insertion.unhighlight([j - 1, j]);
            break;
        }
    }
    insertion.updateBoundary(i);
}

</script>
