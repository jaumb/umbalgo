<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>D3 Test</title>
    <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
    <script type="text/javascript" src="../common.js"></script>
    <script type="text/javascript" src="../factories/element_factory.js">
    </script>
    <script type="text/javascript" src="../factories/tree_factory.js"></script>
    <script type="text/javascript" src="../algorithms/bst.js"></script>
    <script type="text/javascript" src="../vizlib.js"></script>
    <script type="text/javascript" src="../redraw.js"></script>
  </head>
  <body>
    <div class="chart-container" style="max-width: 1000px;"></div>
    <script type="text/javascript">
      var svgW = window.innerWidth;
      var svgH = window.innerHeight;

      var svgCanvasName = 'svg_canvas';

      d3.select(".chart-container")
        .append("svg")
        .attr("width", svgW)
        .attr("height", svgH)
        .attr('id',svgCanvasName);

      redraw.initCanvas(svgCanvasName);

      // duration for visualization
      var stepDur = 500;
      var root = null;
      var ids = 1;

      // get the BST visualization
      var viz = vizlib.get_bst(root, svgW, svgH);

      // get 5 randomly ordered integers
      elements = d3.range(1,6);
      d3.shuffle(elements);

      ////////////////////////// MAIN LOOP ////////////////////////////////////
      // visualize inserting elements one at a time
      next();

      function next() {
        insertElem(elements.shift());
      };

      // execute next step in the algorithm
      function insertElem(elem) {
        if (!elem) { return; }
        var newElem = new node(ids++, elem, null, null);
        redraw.onAnimationEnd(function() { addNodeAndDraw(newElem); });
        redraw.addOpsAndDraw(viz, stepDur, viz.dispNextNode(newElem));
      }

      // add a node to the tree and update tree visualization
      function addNodeAndDraw(newElem) {
        root = addNode(root, newElem);
        redraw.onAnimationEnd(next);
        redraw.addOpsAndDraw(viz, stepDur, viz.buildTree(root));
      }

      // add a node to the tree rooted at rootNode
      function addNode(rootNode, newNode) {
        if (!rootNode) {
          return newNode;
        } else if (newNode.val() > rootNode.val()) {
          rootNode.setRChild(addNode(rootNode.rChild(), newNode, rootNode));
        } else if (newNode.val() < rootNode.val()) {
          rootNode.setLChild(addNode(rootNode.lChild(), newNode, rootNode));
        }
        return rootNode;
      }

      function highlight(n1,n2) {
        redraw.onAnimationEnd(function() { unhighlight(n1,n2); });
        redraw.addOpsAndDraw(viz, stepDur, viz.buildTree(root));
      }

      function unhighlight(n1,n2) {
      }

      function emph(n1) {
      }

      function movemph(n1,n2) {
      }

      // tree node representation
      // id(), val(), lChild(), and rChild() are expected by tree visualizations
      function node(uid, nodeVal, lc, rc) {
        var _id = uid;
        var _val = nodeVal;
        var _lc = lc;
        var _rc = rc;

        var id = function() { return _id; }
        var val = function() { return _val; }
        var lChild = function() { return _lc; }
        var rChild = function() { return _rc; }
        var setLChild = function(child) { _lc = child; }
        var setRChild = function(child) { _rc = child; }

        return {
          id:id,
          val:val,
          lChild:lChild,
          rChild:rChild,
          setLChild:setLChild,
          setRChild:setRChild
        };
      }

    </script>
  </body>
</html>
