<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
    width:960px;
    margin:10px auto;
}
circle {
  fill:white;
  stroke:steelblue;  
  stroke-width:2px;
}
line {
  stroke:grey;
  stroke-width:3px;
}
#navdiv {
    background:#555;
}
#treesvg {
    border:1px solid grey;
}
#navdiv button, #navdiv textarea {
    vertical-align:middle;
}
#g_labels text {
    text-anchor:middle;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>
function unbalancedBST(dur) {
    var svgW = 958, svgH = 460, vRad = 20;
    var dx = 40; // change in x going from parent to child node
    var dy = 70; // change in y going from parent to child node
    var intervalID = null; // for clearing the timer interval task
    var q = []; // queue for storing actions on the visualization
    var tree = {nodes:[]}; // unbalanced tree's visualization
    tree.cx = svgW/2;
    tree.cy = 30;
    tree.w = 40;
    tree.nodeSp = {x:30, y:30}; // starting position of new nodes
    tree.size = 0; // keep track of the number of nodes added to the tree

    // highlight nodes at positions in the insertion sequence
    tree.highlight = function(elements) {
        q.push(function() {
            positions.forEach(function(i) {
                tree.nodes[i - 1].fill = 'lime';
            });
        });
    }

    // clear the highlighting of nodes at the insertion sequence positions
    tree.unhighlight = function(elements) {
        q.push(function() {
            positions.forEach(function(i) {
                tree.nodes[i - 1].fill = 'white';
            });
        });
    }

    // display the next element to be added to the tree
    tree.displayNextElem = function(elem) {
        q.push(function() {
            tree.nodes.push({
                val:elem,
                sp:{},
                pos:{x:tree.nodeSP.x, y:tree.nodeSP.y},
                lc:null,
                rc:null
            });
        });
    }

    // add root element to the tree
    tree.addRoot = function(e) {
        q.push(function() {

            tree.size++;
        });
    }

    // add e1 to the tree to the right of e2
    tree.addRightChild = function(e1, e2) {
        q.push(function() {
            node1 = tree.find(e1);
            node2 = tree.find(e2);
            node2.rc = node1;
            node1.sp.x = node1.pos.x;
            node1.sp.y = node1.pos.y;
            node1.pos.x = node2.pos.x + dx;
            node1.pos.y = node2.pos.y + dy;
            tree.reposition();
            tree.size++;
        });
    }

    // add e1 to the tree to the left of e2
    tree.addLeftChild = function(e1, e2) {
        q.push(function() {
            node1 = tree.find(e1);
            node2 = tree.find(e2);
            node2.lc = node1;
            node1.sp.x = node1.pos.x;
            node1.sp.y = node1.pos.y;
            node1.pos.x = node2.pos.x - dx;
            node1.pos.y = node2.pos.y + dy;
            tree.reposition();
            tree.size++;
        });
    }

    // get the height of the tree
    tree.getHeight = function() {
        function getHeight(node) {
            if (!node) {
                return 0;
            } else if (node.lc && node.rc) {
                return node.l;
            } else {
                return Math.max(getHeight(node.lc), getHeight(node.rc));
            }
        }
        return getHeight(tree.root);
    }

    // get a list of all nodes in the tree
    tree.getNodes = function() {
        var nodes = [];
        function getNodes(node) {
            if (!node) { return; }
            nodes.push({val:node.val, size:node.size, lc:node.lc, rc:node.rc,
                            pos:node.pos, seq:node.seq, sp:tree.nodeSp});
            getNodes(node.lc);
            getNodes(node.rc);
        }
        if (tree.root) {
            getNodes(tree.root);
        }
        return nodes.sort(function(a, b) { return a.seq - b.seq; });
    }
    
    // get a list of all edges in the tree
    tree.getEdges = function() {
        var edges = [];
        function getEdges(e) {
            if (!e) { return; }
            if (e.lc) {
                edges.push({v1:e.val, p1:e.pos, v2:e.lc.val, p2:e.lc.pos,
                                                        seq:e.lc.seq});
                getEdges(e.lc);
            }
            if (e.rc) {
                edges.push({v1:e.val, p1:e.pos, v2:e.rc.val, p2:e.rc.pos,
                                                        seq:e.rc.seq});
                getEdges(e.rc);
            }
        }
        getEdges(tree.root);
        return edges.sort(function(a, b) { return a.seq - b.seq; });
    }

    // adjust the position of all nodes on the tree
    tree.reposition = function(node) {
        // get the number leaves in the tree rooted at node
        getLeafCount = function(node) {
            if (!node) {
                return 0;
            } else if (!node.lc && !node.rc) {
                return 1;
            } else {
                return getLeafCount(node.lc) + getLeafCount(node.rc);
            }
        }

        if (!node) { return; }

        var lCount = getLeafCount(node);
        if (node.lc) {
            node.lc.pos.x = (node.pos.x - dx) -
                    (tree.getHeight() - node.lc.l) * tree.w*(lCount-1)/2;
            tree.reposition(node.lc);
        }
        if (node.rc) {
            node.rc.pos.x = (node.pos.x + dx) +
                    (tree.getHeight() - node.rc.l) * tree.w*(lCount-1)/2;
            tree.reposition(node.rc);
        }
    }
    
    // reset the tree
    tree.reset = function() {
        if (intervalID) {
            clearInterval(intervalID);
            intervalID = null;
        }
        d3.select('#g_lines').html(null);
        d3.select('#g_circles').html(null);
        d3.select('#g_labels').html(null);
        tree.root = null;
        tree.size = 0;
        redraw();
    }

    // take the next step in the algorithm
    // (executes every dur milliseconds)
    tree.step = function() {
        if (q.length > 0) {
            var callback = q.shift();
            callback();
            redraw();
        }
    }
    
    // pause or play the visualization
    tree.pauseplay = function() {
        if (!intervalID) {
            intervalID = setInterval(tree.step, dur);
        } else {
            clearInterval(intervalID);
            intervalID = null;
        }
    }

    // redraw the tree on the canvas
    // this function defines the animation of adding nodes to the tree
    redraw = function() {

        // draw all edges
        var edges = d3.select("#g_lines")
                        .selectAll('line')
                        .data(tree.getEdges());

        edges.transition().duration(dur)
            .attr('x1', function(d) { return d.p1.x; })
            .attr('y1', function(d) { return d.p1.y; })
            .attr('x2', function(d) { return d.p2.x; })
            .attr('y2', function(d) { return d.p2.y; });

        edges.enter()
            .append('line')
            .attr('x1', function(d) { return d.p1.x; })
            .attr('y1', function(d) { return d.p1.y; })
            .attr('x2', function(d) { return d.p1.x; })
            .attr('y2', function(d) { return d.p1.y; })
            .transition().duration(dur)
            .attr('x2', function(d) { return d.p2.x; })
            .attr('y2', function(d) { return d.p2.y; });

        // draw all nodes
        var circles = d3.select("#g_circles")
                            .selectAll('circle')
                            .data(tree.getNodes());

        circles.transition().duration(dur)
            .attr('cx', function(d) { return d.pos.x; })
            .attr('cy', function(d) { return d.pos.y; });

        circles.enter()
            .append('circle')
            .attr('cx', function(d) { return d.sp.x; })
            .attr('cy', function(d) { return d.sp.y; })
            .attr('r', vRad)
            .transition().duration(dur)
            .attr('cx', function(d) { return d.pos.x; })
            .attr('cy', function(d) { return d.pos.y; });

        // draw all labels
        var labels = d3.select("#g_labels")
                            .selectAll('text')
                            .data(tree.getNodes());

        labels.text(function(d) { return d.val; })
            .transition().duration(dur)
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 5; });

        labels.enter()
            .append('text')
            .attr('x', function(d) { return d.sp.x; })
            .attr('y', function(d) { return d.sp.y + 5; })
            .text(function(d) { return d.val; })
            .transition().duration(dur)
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 5; });        

    }
    
    // initialize the visualization layout
    initialize = function() {

        // append svg header bar
        d3.select("body")
            .append("div")
            .attr('id','navdiv');
        
        // add start button to header bar
        d3.select("#navdiv")
            .append("button")
            .attr('type','button')
            .text('Pause/Play')
            .on('click', function(d) { return tree.pauseplay(); });
        
        // append the svg canvas
        d3.select("body")
            .append("svg")
            .attr("width", svgW)
            .attr("height", svgH)
            .attr('id','treesvg');

        // append element for holding edges
        d3.select("#treesvg")
            .append('g')
            .attr('id','g_lines');

        // append element for holding vertices
        d3.select("#treesvg")
            .append('g')
            .attr('id','g_circles');
            
        // append element for holding vertex labels
        d3.select("#treesvg")
            .append('g')
            .attr('id','g_labels');

    }

    initialize();
    return tree;
}

// example of a client using the tree visualization
var tree = {root:null};
var treeViz = unbalancedBST(1000);

// get 10 randomly ordered integers
elements = d3.range(1,11);
d3.shuffle(elements);

// function to add a new element to the tree
function addNode(currNode, newNode) {
    if (!currNode) {
        return newNode;
    } else if (newNode.val > currNode.val) {
        newNode.pos = {x:currNode.pos.x + dx, y:currNode.pos.y + dy};
        currNode.rc = addNode(currNode.rc, newNode);
        currNode.size++;
    } else if (newNode.val < currNode.val) {
        newNode.pos = {x:currNode.pos.x - dx, y:currNode.pos.y + dy};
        currNode.lc = addNode(currNode.lc, newNode);
        currNode.size++;
    }
    newNode.l += 1;
    return currNode;
}


</script>
