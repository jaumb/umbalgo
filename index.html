<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
    width:960px;
    margin:10px auto;
}
circle {
  fill:white;
  stroke:steelblue;  
  stroke-width:2px;
}
line {
  stroke:grey;
  stroke-width:3px;
}
.incRect {
    stroke:grey;
    shape-rendering:crispEdges;
}
#treesvg g text:hover, #treesvg g circle:hover {
    cursor:pointer;
}
#navdiv {
    background:#555;
}
#treesvg {
    border:1px solid grey;
}
#navdiv button, #navdiv textarea {
    vertical-align:middle;
}
#g_labels text {
    text-anchor:middle;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>
function tree() {
    var nNodes = 10;
    var minVal = 1, maxVal = 100;
    var svgW = 958, svgH = 460, vRad = 20;
    var tree = {cx:svgW/2, cy:30, w:40, h:70};
    var dx = 40; // change in x going from parent to child node
    var dy = 70; // change in y going from parent to child node
    var dur = 1000; // duration of animation in millis
    var delay = 2000; // delay between adding nodes
    var intervalID = undefined; // for clearing the timer interval task
    var sp = {x:30, y:30} // starting position of new nodes
    var count = 1; // keep track of the number of nodes added to the tree

    // just for the presentation:
    var sequences = [
                     [44,59,56,41,93,83,11,14,45,7],
                     [74,39,26,42,93,63,91,79,45,97],
                     [53,11,99,6,82,63,93,73,49,95],
                     [66,29,86,43,67,79,1,24,45,37],
                     [55,19,61,21,91,81,79,19,45,29],
                     [39,9,46,41,73,77,17,17,45,6],
                     [68,56,88,46,96,93,13,34,65,5],
                     [71,27,57,48,72,87,91,44,25,23],
                     [47,41,56,42,89,72,12,27,33,38],
                     [62,53,16,31,96,63,11,4,37,67]
                    ];

    // generate a random int over interval [min, max)
    function generateRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    }

    // get the height of the tree rooted at this node
    function getHeight(node) {
        if (node === undefined) { return 0; }
        else if (node.lc === undefined && node.rc === undefined) { return node.l; }
        else { return Math.max(getHeight(node.lc), getHeight(node.rc)); }
    }

    // get the height of the tree
    tree.getHeight = function() {
        return getHeight(tree.root);
    }

    // get a list of all nodes in the tree
    tree.getNodes = function() {
        var nodes = [];
        function getNodes(node) {
            if (node === undefined) { return; }
            nodes.push({val:node.val, size:node.size, lc:node.lc,
                        rc:node.rc, pos:node.pos, seq:node.seq, sp:sp});
            getNodes(node.lc);
            getNodes(node.rc);
        }
        if (tree.root !== undefined) {
            getNodes(tree.root);
        }
        return nodes.sort(function(a, b) { return a.seq - b.seq; });;
    }
    
    // get a list of all edges in the tree
    tree.getEdges = function() {
        var edges = [];
        function getEdges(e) {
            if (e === undefined) { return; }
            if (e.lc !== undefined) {
                edges.push({v1:e.val, p1:e.pos, v2:e.lc.val, p2:e.lc.pos, seq:e.lc.seq});
                getEdges(e.lc);
            }
            if (e.rc !== undefined) {
                edges.push({v1:e.val, p1:e.pos, v2:e.rc.val, p2:e.rc.pos, seq:e.rc.seq});
                getEdges(e.rc);
            }
        }
        getEdges(tree.root);
        return edges.sort(function(a, b) { return a.seq - b.seq; });
    }

    // add a node to the tree
    tree.addNode = function(node) {
        function addNode(currNode, newNode) {
            if (currNode === undefined) {
                return newNode;
            } else if (newNode.val > currNode.val) {
                newNode.pos = {x:currNode.pos.x + dx, y:currNode.pos.y + dy};
                currNode.rc = addNode(currNode.rc, newNode);
                currNode.size++;
            } else if (newNode.val < currNode.val) {
                newNode.pos = {x:currNode.pos.x - dx, y:currNode.pos.y + dy};
                currNode.lc = addNode(currNode.lc, newNode);
                currNode.size++;
            }
            newNode.l += 1;
            return currNode;
        }
        tree.root = addNode(tree.root, node);
        reposition(tree.root);
        redraw();
    }

    // callback function to add the next element to the tree
    tree.addNextElem = function(elems) {
        var elem = {val:elems.pop(), size:1, pos:{}, seq:count++, l:1};
        if (tree.root === undefined) { elem.pos = {x:tree.cx, y:tree.cy}; }
        tree.addNode(elem);
        if (!(elems.length > 0)) { clearInterval(intervalID); }
    }
    
    // build the tree using randomly generated elements
    tree.buildTree = function() {
        if (intervalID !== undefined) { clearInterval(intervalID); }
        d3.select('#g_lines').html(null);
        d3.select('#g_circles').html(null);
        d3.select('#g_labels').html(null);
        tree.root = undefined;
        count = 1;
        d3.shuffle(sequences);
        var elems = sequences.pop().reverse();
        intervalID = setInterval(tree.addNextElem, delay, elems);
    }
    
    // redraw the tree on the canvas
    // this function defines the animation of adding nodes to the tree
    redraw = function() {

        // draw all edges
        var edges = d3.select("#g_lines").selectAll('line').data(tree.getEdges());

        edges.transition().duration(dur)
            .attr('x1', function(d) { return d.p1.x; })
            .attr('y1', function(d) { return d.p1.y; })
            .attr('x2', function(d) { return d.p2.x; })
            .attr('y2', function(d) { return d.p2.y; });

        edges.enter()
            .append('line')
            .attr('x1', function(d) { return d.p1.x; })
            .attr('y1', function(d) { return d.p1.y; })
            .attr('x2', function(d) { return d.p1.x; })
            .attr('y2', function(d) { return d.p1.y; })
            .transition().duration(dur)
            .attr('x2', function(d) { return d.p2.x; })
            .attr('y2', function(d) { return d.p2.y; });

        // draw all nodes
        var circles = d3.select("#g_circles").selectAll('circle').data(tree.getNodes());

        circles.transition().duration(dur)
            .attr('cx', function(d) { return d.pos.x; })
            .attr('cy', function(d) { return d.pos.y; });

        circles.enter()
            .append('circle')
            .attr('cx', function(d) { return d.sp.x; })
            .attr('cy', function(d) { return d.sp.y; })
            .attr('r', vRad)
            .transition().duration(dur)
            .attr('cx', function(d) { return d.pos.x; })
            .attr('cy', function(d) { return d.pos.y; });

        // draw all labels
        var labels = d3.select("#g_labels").selectAll('text').data(tree.getNodes());

        labels.text(function(d) { return d.val; })
            .transition().duration(dur)
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 5; });

        labels.enter()
            .append('text')
            .attr('x', function(d) { return d.sp.x; })
            .attr('y', function(d) { return d.sp.y + 5; })
            .text(function(d) { return d.val; })
            .transition().duration(dur)
            .attr('x', function(d) { return d.pos.x; })
            .attr('y', function(d) { return d.pos.y + 5; });        
    }
    
    // get the number leaves in the tree rooted at node
    getLeafCount = function(node) {
        if (node === undefined) {
            return 0;
        } else if (node.lc === undefined && node.rc === undefined) {
            return 1;
        } else {
            return getLeafCount(node.lc) + getLeafCount(node.rc);
        }
    }

    // adjust the position of all nodes on the tree
    reposition = function(node) {
        if (node === undefined) { return; }
        var lCount = getLeafCount(node);
        if (node.lc !== undefined) {
            node.lc.pos.x = (node.pos.x - dx) - (tree.getHeight() - node.lc.l)
                                                        * tree.w*(lCount-1)/2;
            reposition(node.lc);
        }
        if (node.rc !== undefined) {
            node.rc.pos.x = (node.pos.x + dx) + (tree.getHeight() - node.rc.l)
                                                        * tree.w*(lCount-1)/2;
            reposition(node.rc);
        }
    }

    // initialize the visualization layout
    initialize = function() {

        // append svg header bar
        d3.select("body")
            .append("div")
            .attr('id','navdiv');
        
        // add start button to header bar
        d3.select("#navdiv")
            .append("button")
            .attr('type','button')
            .text('Start')
            .on('click', function(d) { return tree.buildTree(); });
        
        // append the svg canvas
        d3.select("body")
            .append("svg")
            .attr("width", svgW)
            .attr("height", svgH)
            .attr('id','treesvg');

        // append element for holding edges
        d3.select("#treesvg")
            .append('g')
            .attr('id','g_lines');

        // append element for holding vertices
        d3.select("#treesvg")
            .append('g')
            .attr('id','g_circles');
            
        // append element for holding vertex labels
        d3.select("#treesvg")
            .append('g')
            .attr('id','g_labels');
    }
    initialize();
    return tree;
}
var tree = tree();
</script>
